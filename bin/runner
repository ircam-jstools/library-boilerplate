#!/usr/bin/env node
const watch = require('watch');
const path = require('path');
const fs = require('fs');
const fileStore = require('./fileStore');
const log = require('./log');
const transpiler = require('./transpiler');
const { escapeRegExp, getTime, isJs } = require('./utils');

const cwd = process.cwd();

/* --------------------------------------------------------------------------
 * Configuration
 * -------------------------------------------------------------------------- */

const srcDirectory = path.join(cwd, 'src');
const srcRegExp = new RegExp('^' + srcDirectory);
const distDirectory = path.join(cwd, 'dist');

const babelOptions = JSON.parse(fs.readFileSync(path.join(cwd, '.babelrc')));

const watchOptions = {
  ignoreDotFiles: true,
  ignoreUnreadableDir: true,
  ignoreNotPermitted: true,
  interval: 0.25,
};

const browserifyOptions = {
  debug: true,
  fullPaths: false,
};

// --------------------------------------------------------------------------
// reusable logic
// --------------------------------------------------------------------------

async function transpileOrCopy(filename) {
  const src = await fileStore.get(filename);
  const distFilename = src.abs.replace(srcRegExp, distDirectory);
  const dist = await fileStore.get(distFilename);
  const startTime = getTime();

  if (!isJs(src)) {
    try {
      fse.copySync(src.abs, dist.abs);
      log.copyFileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.copyFileError(src, err);
      return Promise.reject([src, dist]);
    }
  } else {
    try {
      await transpiler.transpile(src, dist, babelOptions);
      log.transpileSuccess(src, dist, getTime(startTime));

      return Promise.resolve([src, dist]);
    } catch(err) {
      log.transpileError(src, err);
      return Promise.reject([src, dist]);
    }
  }
}

async function transpileOrCopyAll() {
  const files = await fileStore.getAll(srcDirectory);
  const pairs = [];

  for (let i = 0; i < files.length; i++) {
    try {
      const src = files[i];
      const pair = await transpileOrCopy(src);
      pairs.push(pair);
    } catch(err) {
      return Promise.reject(err);
    }
  }

  return pairs;
}

async function deleteFile(file) {
  try {
    fileStore.delete(file);
    log.deleteFileSuccess(file);
    return Promise.resolve(file);
  } catch(err) {
    log.deleteFileError(file, err)
    return Promise.reject(file);
  }
}


function __transpile() {
  try {
    transpileOrCopyAll();

    return Promise.resolve();
  } catch(err) {
    return Promise.reject(err);
  }
}

// watch
function __watch() {
  watch.createMonitor(srcDirectory, Object.assign({}, watchOptions), monitor => {
    monitor.on('created', transpileOrCopy);
    monitor.on('changed', transpileOrCopy);
    // delete dist file
    monitor.on('removed', async (filename, stats) => {
      const distFilename = filename.replace(srcRegExp, distDirectory);
      const dist = await fileStore.get(distFilename).then();
      await deleteFile(dist);
    });
  });
}

/* --------------------------------------------------------------------------
 * Parse commands
 * -------------------------------------------------------------------------- */

const command = process.argv[2];

switch (command) {
  case '--watch':
    __transpile().then(__watch).catch(err => console.error(err.stack));
    break;
  case '--transpile':
    __transpile().catch(err => console.error(err.stack));
    break;
}

/* -------------------------------------------------------------------------- */

